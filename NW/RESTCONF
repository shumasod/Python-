#!/usr/bin/env python3
"""
Cisco IOS-XE デバイスにRESTCONFを使用してルート設定を行うスクリプト

このスクリプトはRESTCONF APIを使用してCisco IOS-XEデバイスの
スタティックルートを設定・管理します。
"""
import argparse
import json
import logging
import os
import sys
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Any, Dict, Optional

import requests
import urllib3
from requests.exceptions import ConnectionError, RequestException, Timeout

# SSL/TLS証明書の警告を無効化
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class HttpMethod(Enum):
    """HTTPメソッドの列挙型"""
    GET = "GET"
    POST = "POST"
    PATCH = "PATCH"
    PUT = "PUT"
    DELETE = "DELETE"


class ExitCode(Enum):
    """終了コードの列挙型"""
    SUCCESS = 0
    ERROR = 1
    INTERRUPTED = 130


@dataclass
class RestconfConfig:
    """RESTCONF接続設定"""
    host: str
    username: str
    password: str
    port: int = 443
    timeout: int = 30
    
    def __post_init__(self):
        """設定値の検証"""
        if not self.host:
            raise ValueError("Host is required")
        if not self.username or not self.password:
            raise ValueError("Username and password are required")
        if self.port <= 0 or self.port > 65535:
            raise ValueError(f"Invalid port number: {self.port}")
        if self.timeout <= 0:
            raise ValueError(f"Invalid timeout: {self.timeout}")


class Logger:
    """ロギングユーティリティクラス"""
    
    @staticmethod
    def setup(verbose: bool = False, log_file: str = "restconf_config.log") -> logging.Logger:
        """
        ロガーのセットアップ
        
        Args:
            verbose: 詳細ログを有効にする場合True
            log_file: ログファイルのパス
            
        Returns:
            設定されたロガーインスタンス
        """
        level = logging.DEBUG if verbose else logging.INFO
        
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # ファイルハンドラ
        file_handler = logging.FileHandler(log_file, encoding='utf-8')
        file_handler.setLevel(level)
        file_handler.setFormatter(formatter)
        
        # コンソールハンドラ
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(level)
        console_handler.setFormatter(formatter)
        
        # ロガーの設定
        logger = logging.getLogger(__name__)
        logger.setLevel(level)
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
        return logger


class RestconfClient:
    """RESTCONFを使用してCisco IOS-XEデバイスと通信するクライアント"""
    
    # エンドポイント定義
    ROUTES_ENDPOINT = "data/Cisco-IOS-XE-native:native/ip/route"
    VALIDATION_ENDPOINT = "data?depth=1"
    
    # 成功とみなすHTTPステータスコード
    SUCCESS_CODES = {200, 201, 204}
    
    def __init__(self, config: RestconfConfig, logger: logging.Logger):
        """
        RESTCONFクライアントを初期化
        
        Args:
            config: RESTCONF接続設定
            logger: ロガーインスタンス
        """
        self.config = config
        self.logger = logger
        self.base_url = f"https://{config.host}:{config.port}/restconf"
        self.session = self._create_session()
    
    def _create_session(self) -> requests.Session:
        """
        HTTPセッションを作成
        
        Returns:
            設定されたセッションオブジェクト
        """
        session = requests.Session()
        session.auth = (self.config.username, self.config.password)
        session.headers.update({
            'Content-Type': 'application/yang-data+json',
            'Accept': 'application/yang-data+json'
        })
        session.verify = False
        return session
    
    def _send_request(
        self,
        method: HttpMethod,
        endpoint: str,
        data: Optional[Dict[str, Any]] = None
    ) -> requests.Response:
        """
        RESTCONFエンドポイントにリクエストを送信
        
        Args:
            method: HTTPメソッド
            endpoint: ベースURLに追加するエンドポイントパス
            data: リクエストに含めるJSONデータ
            
        Returns:
            レスポンスオブジェクト
            
        Raises:
            RequestException: リクエスト処理中にエラーが発生した場合
        """
        url = f"{self.base_url}/{endpoint}"
        self.logger.debug(f"Sending {method.value} request to {url}")
        
        if data:
            self.logger.debug(f"Request data: {json.dumps(data, indent=2)}")
        
        try:
            response = self.session.request(
                method=method.value,
                url=url,
                json=data,
                timeout=self.config.timeout
            )
            
            self.logger.debug(f"Response status: {response.status_code}")
            if response.text:
                self.logger.debug(f"Response body: {response.text}")
            
            return response
            
        except Timeout:
            self.logger.error(f"Request timeout ({self.config.timeout}s) for {url}")
            raise
        except ConnectionError as e:
            self.logger.error(f"Connection error for {url}: {e}")
            raise
        except RequestException as e:
            self.logger.error(f"Request error: {e}")
            raise
    
    def validate_connection(self) -> bool:
        """
        デバイスへの接続を検証
        
        Returns:
            接続が成功した場合True
        """
        try:
            response = self._send_request(HttpMethod.GET, self.VALIDATION_ENDPOINT)
            success = response.status_code in self.SUCCESS_CODES
            
            if success:
                self.logger.info("Connection validation successful")
            else:
                self.logger.error(f"Connection validation failed with status {response.status_code}")
            
            return success
            
        except Exception as e:
            self.logger.error(f"Connection validation failed: {e}")
            return False
    
    def get_routes(self) -> Optional[Dict[str, Any]]:
        """
        現在設定されているルートを取得
        
        Returns:
            現在のルート設定、エラー時はNone
        """
        try:
            response = self._send_request(HttpMethod.GET, self.ROUTES_ENDPOINT)
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            self.logger.error(f"Failed to get routes: {e}")
            return None
    
    def configure_routes(self, routes_data: Dict[str, Any]) -> bool:
        """
        ネットワークデバイスにルートを設定
        
        Args:
            routes_data: ルート設定データ
            
        Returns:
            設定が成功した場合True
        """
        try:
            response = self._send_request(
                HttpMethod.PATCH,
                self.ROUTES_ENDPOINT,
                data=routes_data
            )
            
            if response.status_code in self.SUCCESS_CODES:
                self.logger.info("Routes configured successfully")
                return True
            else:
                self.logger.error(
                    f"Failed to configure routes. "
                    f"Status: {response.status_code}, Response: {response.text}"
                )
                return False
                
        except Exception as e:
            self.logger.error(f"Error configuring routes: {e}")
            return False
    
    def close(self):
        """セッションをクローズ"""
        if self.session:
            self.session.close()


class RouteConfigManager:
    """ルート設定管理クラス"""
    
    @staticmethod
    def load_from_file(file_path: str, logger: logging.Logger) -> Optional[Dict[str, Any]]:
        """
        JSONファイルからルート設定をロード
        
        Args:
            file_path: ルート設定を含むJSONファイルのパス
            logger: ロガーインスタンス
            
        Returns:
            ロードされたルート設定データ、エラー時はNone
        """
        try:
            path = Path(file_path)
            if not path.exists():
                logger.error(f"File not found: {file_path}")
                return None
            
            with path.open('r', encoding='utf-8') as f:
                data = json.load(f)
            
            logger.info(f"Successfully loaded routes from {file_path}")
            return data
            
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in {file_path}: {e}")
            return None
        except IOError as e:
            logger.error(f"Failed to read {file_path}: {e}")
            return None
    
    @staticmethod
    def get_sample_routes() -> Dict[str, Any]:
        """
        サンプルルート設定を返す
        
        Returns:
            サンプルルート設定
        """
        return {
            "Cisco-IOS-XE-native:ip": {
                "route": {
                    "ip-route-interface-forwarding-list": [
                        {
                            "prefix": "192.168.2.0",
                            "mask": "255.255.255.0",
                            "fwd-list": [
                                {
                                    "fwd": "GigabitEthernet0/0"
                                }
                            ]
                        },
                        {
                            "prefix": "10.0.0.0",
                            "mask": "255.0.0.0",
                            "fwd-list": [
                                {
                                    "fwd": "Null0"
                                }
                            ]
                        }
                    ]
                }
            }
        }


class CommandLineParser:
    """コマンドライン引数パーサー"""
    
    # 環境変数からのデフォルト値
    DEFAULT_HOST = os.environ.get('NETWORK_HOST', '')
    DEFAULT_USER = os.environ.get('NETWORK_USER', '')
    DEFAULT_PASS = os.environ.get('NETWORK_PASS', '')
    DEFAULT_PORT = int(os.environ.get('NETWORK_PORT', '443'))
    
    @classmethod
    def parse(cls) -> argparse.Namespace:
        """
        コマンドライン引数をパース
        
        Returns:
            パースされた引数
        """
        parser = argparse.ArgumentParser(
            description='Configure routes on Cisco IOS-XE devices using RESTCONF',
            formatter_class=argparse.ArgumentDefaultsHelpFormatter
        )
        
        # 接続設定
        connection_group = parser.add_argument_group('Connection settings')
        connection_group.add_argument(
            '--host',
            default=cls.DEFAULT_HOST,
            help='Network device hostname or IP address'
        )
        connection_group.add_argument(
            '--port',
            type=int,
            default=cls.DEFAULT_PORT,
            help='RESTCONF port number'
        )
        connection_group.add_argument(
            '--username',
            default=cls.DEFAULT_USER,
            help='Authentication username'
        )
        connection_group.add_argument(
            '--password',
            default=cls.DEFAULT_PASS,
            help='Authentication password'
        )
        connection_group.add_argument(
            '--timeout',
            type=int,
            default=30,
            help='Request timeout in seconds'
        )
        
        # ルート設定
        route_group = parser.add_argument_group('Route configuration')
        route_group.add_argument(
            '--routes-file',
            help='JSON file containing route configurations'
        )
        
        # 実行オプション
        execution_group = parser.add_argument_group('Execution options')
        execution_group.add_argument(
            '--verbose', '-v',
            action='store_true',
            help='Enable verbose logging'
        )
        execution_group.add_argument(
            '--dry-run',
            action='store_true',
            help='Validate connection and show route data without applying changes'
        )
        
        return parser.parse_args()


class Application:
    """メインアプリケーションクラス"""
    
    def __init__(self, args: argparse.Namespace):
        """
        アプリケーションを初期化
        
        Args:
            args: コマンドライン引数
        """
        self.args = args
        self.logger = Logger.setup(verbose=args.verbose)
        self.client: Optional[RestconfClient] = None
    
    def run(self) -> ExitCode:
        """
        アプリケーションを実行
        
        Returns:
            終了コード
        """
        try:
            # 設定の作成と検証
            config = self._create_config()
            if not config:
                return ExitCode.ERROR
            
            # クライアントの初期化
            self.client = RestconfClient(config, self.logger)
            
            # 接続検証
            if not self._validate_connection():
                return ExitCode.ERROR
            
            # ルート設定の準備
            routes_data = self._prepare_routes()
            if not routes_data:
                return ExitCode.ERROR
            
            # 現在の設定を表示
            self._show_current_routes()
            
            # Dry-runモードの処理
            if self.args.dry_run:
                return self._handle_dry_run(routes_data)
            
            # ルート設定の適用
            return self._apply_routes(routes_data)
            
        finally:
            if self.client:
                self.client.close()
    
    def _create_config(self) -> Optional[RestconfConfig]:
        """
        RESTCONF設定を作成
        
        Returns:
            設定オブジェクト、エラー時はNone
        """
        try:
            config = RestconfConfig(
                host=self.args.host,
                username=self.args.username,
                password=self.args.password,
                port=self.args.port,
                timeout=self.args.timeout
            )
            return config
            
        except ValueError as e:
            self.logger.error(f"Configuration error: {e}")
            print(f"Error: {e}")
            print("Use --help for usage information.")
            return None
    
    def _validate_connection(self) -> bool:
        """
        接続を検証
        
        Returns:
            検証が成功した場合True
        """
        self.logger.info(
            f"Validating connection to {self.args.host}:{self.args.port}..."
        )
        
        if not self.client.validate_connection():
            print(
                f"Error: Could not connect to {self.args.host}:{self.args.port}. "
                "Please check credentials and network connectivity."
            )
            return False
        
        return True
    
    def _prepare_routes(self) -> Optional[Dict[str, Any]]:
        """
        ルート設定データを準備
        
        Returns:
            ルート設定データ、エラー時はNone
        """
        if self.args.routes_file:
            self.logger.info(f"Loading routes from {self.args.routes_file}")
            routes_data = RouteConfigManager.load_from_file(
                self.args.routes_file,
                self.logger
            )
            
            if not routes_data:
                print(f"Error: Could not load valid route data from {self.args.routes_file}")
                return None
        else:
            self.logger.info("Using sample route configuration")
            routes_data = RouteConfigManager.get_sample_routes()
        
        return routes_data
    
    def _show_current_routes(self):
        """現在のルート設定を表示"""
        current_routes = self.client.get_routes()
        
        if current_routes:
            self.logger.info("Current routes configuration:")
            self.logger.info(json.dumps(current_routes, indent=2))
        else:
            self.logger.warning("Could not retrieve current routes")
    
    def _handle_dry_run(self, routes_data: Dict[str, Any]) -> ExitCode:
        """
        Dry-runモードを処理
        
        Args:
            routes_data: 適用予定のルート設定
            
        Returns:
            終了コード
        """
        self.logger.info("Dry run mode - changes will not be applied")
        print("\n=== Dry Run Mode ===")
        print("Connection: OK")
        print("\nProposed route configuration:")
        print(json.dumps(routes_data, indent=2))
        print("\nNo changes were applied.")
        return ExitCode.SUCCESS
    
    def _apply_routes(self, routes_data: Dict[str, Any]) -> ExitCode:
        """
        ルート設定を適用
        
        Args:
            routes_data: ルート設定データ
            
        Returns:
            終了コード
        """
        self.logger.info("Applying route configuration...")
        
        if self.client.configure_routes(routes_data):
            print("✓ Routes configured successfully")
            return ExitCode.SUCCESS
        else:
            print("✗ Failed to configure routes")
            return ExitCode.ERROR


def main() -> ExitCode:
    """
    メイン実行関数
    
    Returns:
        終了コード
    """
    args = CommandLineParser.parse()
    app = Application(args)
    return app.run()


if __name__ == '__main__':
    try:
        exit_code = main()
        sys.exit(exit_code.value)
        
    except KeyboardInterrupt:
        print("\n\nOperation cancelled by user")
        sys.exit(ExitCode.INTERRUPTED.value)
        
    except Exception as e:
        logging.exception("Unhandled exception")
        print(f"\nFatal error: {e}")
        sys.exit(ExitCode.ERROR.value)
